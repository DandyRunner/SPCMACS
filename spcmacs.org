#+TITLE: SPCMACS
#+AUTHOR: Erwin Jansen
#+PROPERTY: header-args :tangle yes

* Header
#+BEGIN_SRC emacs-lisp
;;; init.el -*- lexical-binding: t; -*-
#+END_SRC
* Personal Information
Personal information, to be used for instance for email and git.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Erwin Jansen"
      user-mail-address "echjansen@outlook.com"
      auth-sources (list (expand-file-name "~/.authinfo.gpg")))
#+END_SRC
* Bootup
Garbage collection on hold while the init scrips runs, and redirect the custom paramaters to be written in a seperate file rather than this init file (spcmacs.el)
#+BEGIN_SRC emacs-lisp
  (eval-and-compile
    (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6))

  (eval-and-compile
    (setq-default custom-file (expand-file-name "custom.el" user-emacs-directory))
    (when (file-exists-p custom-file)
      (load custom-file)))

  (defvar temp--file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+END_SRC
* Package Sources
#+BEGIN_SRC emacs-lisp
  ;;;We’re going to set the load-path ourselves and avoid calling (package-initilize) (for performance reasons) so we need to set package--init-file-ensured to true to tell package.el to not automatically call it on our behalf. Additionally we’re setting package-enable-at-startup to nil so that packages will not automatically be loaded for us since use-package will be handling that.
  (eval-and-compile
    (setq load-prefer-newer t
          package-user-dir "~/.emacs.d/.elpa"
          package--init-file-ensured t
          package-enable-at-startup nil)

    (unless (file-directory-p package-user-dir)
      (make-directory package-user-dir t))

    (setq load-path (append load-path (directory-files package-user-dir t "^[^.]" t))))

  (eval-when-compile
    (require 'package)
    ;; tells emacs not to load any packages before starting up
    ;; the following lines tell emacs where on the internet to look up
    ;; for new packages.
    (setq package-archives '(("melpa"     . "https://melpa.org/packages/")
                             ("elpa"      . "https://elpa.gnu.org/packages/")
                             ("repo-org"  . "https://orgmode.org/elpa/")))
    ;; (package-initialize)
    (unless package--initialized (package-initialize t))

    ;; Bootstrap `use-package'
    (unless (package-installed-p 'use-package) ; unless it is already installed
      (package-refresh-contents) ; updage packages archive
      (package-install 'use-package)) ; and install the most recent version of use-package

    (require 'use-package)
    (setq use-package-always-ensure t))
#+END_SRC
* Sensible defaults
#+BEGIN_SRC emacs-lisp
  (setq fill-column 80)  ; toggle wrapping text at the 80th character
  (setq scroll-conservatively 101)
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
  (setq-default indent-tabs-mode nil)
  (global-hl-line-mode 1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (blink-cursor-mode 0)
  (winner-mode 1)
  (put 'narrow-to-region 'disabled nil)
  (add-hook 'window-setup-hook 'toggle-frame-fullscreen t)
  (setq auto-revert-check-vc-info t) ;;TODO - possible performance issue
  (setq evil-normal-state-tag " NORMAL")
  (setq evil-insert-state-tag " INSERT")
  (setq evil-visual-state-tag " VISUAL")
#+END_SRC
** Backups and auto save 
#+BEGIN_SRC emacs-lisp
  ;; Put backup files neatly away
  (let ((backup-dir "~/.emacs.d/.backups")
        (auto-saves-dir "~/.emacs.d/.auto-saves/"))
    (dolist (dir (list backup-dir auto-saves-dir))
      (when (not (file-directory-p dir))
        (make-directory dir t)))
    (setq backup-directory-alist `(("." . ,backup-dir))
          auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
          auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
          tramp-backup-directory-alist `((".*" . ,backup-dir))
          tramp-auto-save-directory auto-saves-dir))

  (setq backup-by-copying t    ; Don't delink hardlinks
        delete-old-versions t  ; Clean up the backups
        version-control t      ; Use version numbers on backups,
        kept-new-versions 5    ; keep some new versions
        kept-old-versions 2)   ; and some old ones, too
#+END_SRC
* Which Key
What would we be without the key popup help appearing when hitting M-x or M-c?
In combination with general.el we also have which-key help with the leader key SPC.
#+BEGIN_SRC emacs-lisp
 (use-package which-key
   :config (which-key-mode 1))
#+END_SRC
* General
General is a generic package for concise key binding in emacs.
#+BEGIN_SRC emacs-lisp 
  (use-package general
    :after which-key
    :config
    (general-override-mode 1)

    (general-create-definer evil-def
      :states '(normal)
      :prefix "SPC")

    (general-create-definer emacs-def
       :states '(emacs)
       :prefix "s-SPC")

    (evil-def 'normal
      :prefix "SPC"
      "a"  '(:ignore t :which-key "applications")
      "b"  '(:ignore t :which-key "buffer")
      "f"  '(:ignore t :which-key "file")
      "g"  '(:ignore t :which-key "git")
      "s"  '(:ignore t :which-key "search")
      "t"  '(:ignore t :which-key "toggle")
      "w"  '(:ignore t :which-key "window"))

    (general-def
      :keymaps 'key-translation-map
      "ESC" (kbd "C-g"))

    (general-def
      :prefix "C-c"
      "a" 'org-agenda
      "c" 'org-capture)
    )
#+END_SRC
* Evil Mode
There is no better way but vim editing. This further allows for SPC for a leader key
#+BEGIN_SRC emacs-lisp
(use-package evil
  :hook (after-init . evil-mode)
  :config
  (setq doc-view-continues t)
  :general
  (evil-def
    "wh"  '(evil-window-left :wk "window left")
    "wl"  '(evil-window-right :wk "window right")
    "wj"  '(evil-window-down :wk "window down")
    "wk"  '(evil-window-up :wk "window up"))) 
#+END_SRC 
** Evil Commentary
Handy tool to comment blocks of code
#+BEGIN_SRC emacs-lisp 
(use-package evil-commentary
  :after evil
  :config
  (evil-commentary-mode 1)
  :general
  ('normal override-global-map
    "gc" '(evil-commentary :wk "comment")
    "gC" '(evil-commentary-line :wk "comment line"))) 
#+END_SRC 
* Narrowing System
** Ivy
Ivy is for quick and easy selection from a list. 
When Emacs prompts for a string from a list of several possible choices, 
Ivy springs into action to assist in narrowing and picking the right string from a vast number of choices. 
#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :hook (after-init . ivy-mode)
    :commands (ivy-switch-buffer)
    :config
    (progn
      (setq ivy-use-virtual-buffers t
            ivy-count-format "(%d/%d) "
            ivy-truncate-lines nil
            ivy-initial-inputs-alist nil)
      (setq ivy-re-builders-alist
            '((t . ivy--regex-plus))))
    :general
    (evil-def
      "bm"  'ivy-switch-buffer))
#+END_SRC
** Counsel
A collection of Ivy-enhanced versions of common Emacs commands
#+BEGIN_SRC emacs-lisp
    (use-package counsel
      :after ivy
      :general
      (general-def
        "M-x"      '(counsel-M-x :wk "M-x")
        "C-x C-f"  '(counsel-find-file :wk "find file"))
      (evil-def
        "SPC"      '(counsel-M-x :wk "M-x")
        "ff"       '(counsel-find-file :wk "find file")
        "fr"       '(counsel-recentf :wk "recent files")
        "fL"       '(counsel-locate :wk "locate file")))
#+END_SRC
** Swiper
An Ivy-enhanced alternative to isearch.
#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :commands (swiper)
    :general
    (general-def
      "C-s"  'swiper)
    (evil-def
      "ss"  'swiper))
#+END_SRC
* Auto Completion
** Company
Company is an auto completion tool for programming languages.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :hook (after-init . global-company-mode)
    :commands (company-complete-common
               company-manual-begin
               company-grab-line)
    :init
    (progn
      (setq company-idle-delay .1
            company-tooltip-limit 10
            company-tooltip-align-annotations t
            company-minimum-prefix-length 2
            company-require-match 'never
            company-dabbrev-code-other-buffers t
            company-dabbrev-ignore-case nil
            company-dabbrev-downcase nil
            ))
    :config
    (progn
      (setq company-backends
            '(company-keywords
              company-files
              company-capf
              company-dabbrev-code
              company-dabbrev))
      (setq company-frontends '(company-echo-metadata-frontend
                                company-pseudo-tooltip-unless-just-one-frontend
                                company-preview-frontend))
      (setq company-backends '((company-capf company-files)
                               (company-dabbrev-code company-keywords)
                               company-dabbrev
                               company-yasnippet)))
    :general
    (general-def
      "C-n"  'company-select-next
      "C-p"  'company-select-previous))
#+END_SRC
** Auto Complete
Since Company mode does not appear to kick in - lets try auto-complete mode.
#+BEGIN_SRC emacs-lisp :tangle off
  (use-package auto-complete
    :config
    (ac-config-default))
#+END_SRC
* Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit-status)
    :general
    (evil-def
      "gs"  'magit-status))
 #+END_SRC
* Theme
Add the doom theme, as it's clean and fast
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :hook (after-init . load-doom-vibrant)
    :config
    (defun load-doom-one()
      "Load Doom One Theme"
      (interactive)
      (load-theme 'doom-one))
    (defun load-doom-light()
      "Load Doom One Light Theme"
      (interactive)
      (load-theme 'doom-one-light))
    (defun load-doom-vibrant()
      "Load Doom One Vibrant Theme"
      (interactive)
      (load-theme 'doom-vibrant))
    (doom-themes-visual-bell-config)
    (doom-themes-org-config)
    :general
    (evil-def
      "tt"  '(:ignore t :wk "themes")
      "ttd" 'load-doom-one
      "ttl" 'load-doom-light
      "ttv" 'load-doom-vibrant))
#+END_SRC
* Powerline
** Doom Modeline
 Doom powerline together with the Doom theme, clean and fast
 #+BEGIN_SRC emacs-lisp
   (use-package doom-modeline
     :ensure t
     :hook (after-init . doom-modeline-mode)
     :config
     (setq
      doom-modeline-buffer-file-name-style 'truncate-upto-project
      doom-modeline-icon t
      doom-modeline-major-mode-icon t
      doom-modeline-major-mode-color-icon t
      doom-modeline-minor-modes t
      doom-modeline-word-count t
      doom-modeline-checker-simple-format t
      doom-modeline-vcs-max-length 12
      doom-modeline-persp-name t
      doom-modeline-lsp t
      doom-modeline-github t
      doom-modeline-github-interval (* 30 60)
      doom-modeline-mu4e t
      doom-modeline-ircstylize 'identity))
 #+END_SRC
** Moody Modeline
This is the latest from the develoer of Magit, and thus has potential.
Bt still in early stages, and appears rather simple in functionality yet
#+BEGIN_SRC emacs-lisp :tangle off
  (use-package moody
    :ensure t
    :config
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode))
#+END_SRC
* Finishing Up
#+BEGIN_SRC emacs-lisp
   (eval-and-compile
     (add-hook 'emacs-startup-hook '(lambda ()
                                      (setq gc-cons-threshold 16777216
                                            gc-cons-percentage 0.1
                                            file-name-handler-alist
                                            temp--file-name-handler-alist))))

   (setq initial-scratch-message (concat "Startup time: " (emacs-init-time)))
#+END_SRC
* Notes
** Profiling
Install esup, and run the commmand form the commandline.
